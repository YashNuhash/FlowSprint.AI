export interface MindMapNode {
  id: string;
  title: string;
  description: string;
  type: 'start' | 'task' | 'milestone' | 'component' | 'end';
  position: { x: number; y: number };
  status: 'pending' | 'in_progress' | 'completed';
  priority: 'low' | 'medium' | 'high' | 'critical';
  estimatedHours?: number;
  dependencies?: string[];
}

export interface ProjectData {
  _id?: string;
  id?: string;
  name: string;
  description: string;
  features: Record<string, string[]> | string[];
  techStack?: string[];
  tags?: string[];
  nodes: MindMapNode[];
  mindmap?: any;
  prd?: any;
  createdAt?: string;
  updatedAt?: string;
}

/**
 * Convert backend mindmap tree structure to frontend nodes array
 */
export function convertMindmapToNodes(mindmap: any): MindMapNode[] {
  if (!mindmap) return [];

  const nodes: MindMapNode[] = [];
  let nodeCounter = 0;

  // Helper function to traverse the tree and create nodes
  function traverseNode(node: any, level: number = 0, parentIndex: number = 0): void {
    if (!node) return;

    // Create a node from current item
    const currentNode: MindMapNode = {
      id: node.id || `node_${nodeCounter++}`,
      title: node.text || node.title || 'Untitled',
      description: node.description || (node.text || node.title || 'Component') + ': Implementation and technical details',
      type: determineNodeType(node.text || node.title || '', level),
      position: { 
        x: (level * 400) + 150,  // Increased spacing for better horizontal spread
        y: (parentIndex * 120) + 150 
      },
      status: 'pending',
      priority: level === 0 ? 'high' : level === 1 ? 'medium' : 'low',
      estimatedHours: Math.ceil(Math.random() * 8) + 1
    };

    nodes.push(currentNode);

    // Process children if they exist
    if (node.children && Array.isArray(node.children)) {
      node.children.forEach((child: any, index: number) => {
        traverseNode(child, level + 1, nodes.length + index);
      });
    }
  }

  // Helper function to determine node type based on content
  function determineNodeType(text: string, level: number): MindMapNode['type'] {
    const lowerText = text.toLowerCase();
    
    if (level === 0) return 'start';
    if (lowerText.includes('deploy') || lowerText.includes('launch')) return 'end';
    if (lowerText.includes('milestone') || lowerText.includes('phase')) return 'milestone';
    if (lowerText.includes('component') || lowerText.includes('module')) return 'component';
    
    return 'task';
  }

  // Start traversal from root
  traverseNode(mindmap, 0, 0);

  return nodes;
}

/**
 * Convert frontend nodes array back to backend mindmap tree structure
 */
export function convertNodesToMindmap(nodes: MindMapNode[]): any {
  if (!nodes || nodes.length === 0) return null;

  // Simple conversion - just return the first node with children as array
  const startNode = nodes.find(node => node.type === 'start') || nodes[0];
  const otherNodes = nodes.filter(node => node.id !== startNode.id);

  return {
    id: startNode.id,
    text: startNode.title,
    title: startNode.title,
    description: startNode.description,
    children: otherNodes.map(node => ({
      id: node.id,
      text: node.title,
      title: node.title,
      description: node.description,
      type: node.type,
      status: node.status,
      priority: node.priority,
      estimatedHours: node.estimatedHours
    }))
  };
}

/**
 * Convert raw project data from backend to frontend format
 */
export function convertProjectData(rawProject: any): ProjectData {
  console.log('Converting raw project data:', rawProject);
  
  // Handle features - ensure it's an array for frontend display
  let featuresArray: string[] = [];
  if (rawProject.features) {
    if (Array.isArray(rawProject.features)) {
      featuresArray = rawProject.features;
    } else if (typeof rawProject.features === 'object') {
      // Convert object to flat array
      featuresArray = Object.values(rawProject.features).flat().filter(f => typeof f === 'string') as string[];
    }
  }

  // Convert mindmap to nodes - no fallback since mindmaps are auto-generated
  let nodes: MindMapNode[] = [];
  
  if (rawProject.mindmap) {
    nodes = convertMindmapToNodes(rawProject.mindmap);
    console.log('✅ Converted AI-generated mindmap to nodes:', nodes.length);
  } else {
    console.log('⏳ No mindmap yet - will be auto-generated by backend');
    // Return empty array - mindmap will be auto-generated during project creation
    nodes = [];
  }

  const convertedProject: ProjectData = {
    _id: rawProject._id || rawProject.id,
    id: rawProject._id || rawProject.id,
    name: rawProject.name || rawProject.product || 'Untitled Project',
    description: rawProject.description || 'No description provided',
    features: featuresArray,
    techStack: rawProject.techStack || [],
    tags: rawProject.tags || [],
    nodes: nodes,
    mindmap: rawProject.mindmap,
    prd: rawProject.prd,
    createdAt: rawProject.createdAt,
    updatedAt: rawProject.updatedAt
  };

  console.log('Converted project data:', convertedProject);
  return convertedProject;
}

/**
 * Generate sample nodes for testing
 */
export function generateSampleNodes(): MindMapNode[] {
  return [
    {
      id: 'start-1',
      title: 'Project Setup',
      description: 'Initialize the project structure and set up the development environment',
      type: 'start',
      position: { x: 100, y: 200 },
      status: 'completed',
      priority: 'high',
      estimatedHours: 4
    },
    {
      id: 'task-1',
      title: 'User Authentication',
      description: 'Implement user registration, login, and authentication flow',
      type: 'task',
      position: { x: 400, y: 150 },
      status: 'in_progress',
      priority: 'high',
      estimatedHours: 8,
      dependencies: ['start-1']
    },
    {
      id: 'task-2',
      title: 'Database Design',
      description: 'Design and implement the database schema for the application',
      type: 'task',
      position: { x: 400, y: 250 },
      status: 'pending',
      priority: 'medium',
      estimatedHours: 6,
      dependencies: ['start-1']
    },
    {
      id: 'milestone-1',
      title: 'MVP Complete',
      description: 'Minimum viable product with core features completed',
      type: 'milestone',
      position: { x: 700, y: 200 },
      status: 'pending',
      priority: 'critical',
      estimatedHours: 0,
      dependencies: ['task-1', 'task-2']
    },
    {
      id: 'end-1',
      title: 'Project Launch',
      description: 'Deploy to production and launch the application',
      type: 'end',
      position: { x: 1000, y: 200 },
      status: 'pending',
      priority: 'high',
      estimatedHours: 4,
      dependencies: ['milestone-1']
    }
  ];
}